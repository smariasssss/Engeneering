# Тема 11. Итераторы и генераторы
Отчет по Теме №11 выполнила:
- Санжанова Мария Олеговна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ |---------|
| Задание 1 | + | +       |
| Задание 2 | + | +       |
| Задание 3 | + | нет     |
| Задание 4 | + | нет     |
| Задание 5 | + | нет     |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа.
### Задание 1. 
Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev()
### Результат 
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202023-11-11%20%D0%B2%2017.10.16.png)

### Выводы 
Этот код создает список `numbers` с элементами от 0 до 5 включительно, а затем использует цикл `for` для итерации по каждому элементу списка и вывода его на экран.
Каждое число из списка `numbers` будет напечатано в новой строке.

### Задание 2. 
Класс итератор с гибкой настройкой и удобными применением.
### Результат 
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202023-11-11%20%D0%B2%2017.16.08.png)
### Выводы 
Этот код создает класс `CountDown`, который представляет собой итератор для обратного отсчета от заданного числа до 0. 
Таким образом, при выполнении кода будет выведен обратный отсчет от 5 до 0.

### Задание 3. 
Генератор списка.
### Результат 
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/5.png)
### Выводы 
Создается список `a`, содержащий квадраты чисел от 1 до 4 (включительно). Это делается с использованием генератора списка.
Запускается цикл `for`, который проходит по элементам списка `a` и выводит каждый элемент на экран.
Выводится итератор для списка `a` с помощью функции `iter()`.
Запускается еще один цикл `for`, который также проходит по элементам списка `a` и выводит каждый элемент на экран.
Стоит обратить внимание на то, что второй цикл `for` проходит по списку `a` заново, несмотря на то, что первый цикл уже прошел по всем элементам. Это связано с тем, что итератор в Python "запоминает" свое текущее состояние. При использовании цикла `for` снова, он начинает с начала списка.

### Задание 4. 
Выражения генераторы.
### Результат 
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/6.png)
### Выводы 
Создается генераторное выражение `b`, которое представляет собой последовательность квадратов чисел от 1 до 4 (включительно).
Выводится объект генератора. Выводится строка 'first'. Запускается первый цикл `for`, который проходит по элементам генератора `b` и выводит каждый элемент на экран.
Выводится строка 'second'. Запускается второй цикл `for`. Однако, генератор уже исчерпан в первом цикле, поэтому этот цикл не проходит ни по одному элементу.
Стоит обратить внимание на то, что генераторы в Python обычно итерируются только один раз. После того как генератор был использован, он исчерпывается, и для повторного прохода нужно создавать новый генератор. В данном случае, второй цикл `for` не выполняется, так как генератор `b` уже был полностью использован в первом цикле.

### Задание 5. 
Такой же счетчик, как и в первом задании, только это генератор и использует yield
### Результат 
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/6.png)
### Выводы 
Определение функции `countdown`, которая является генератором. Она принимает аргумент `count`. Запускается цикл `while`, который будет выполняться, пока `count` не станет отрицательным. На каждой итерации цикла генератор возвращает текущее значение `count` и приостанавливает свое выполнение, сохраняя свое состояние. Это позволяет использовать генератор для ленивого производства значений.
Далее происхоит уменьшение значения `count` перед следующей итерацией. Далее создается объект генератора `counter` с начальным значением 5.
Запускается цикла `for`, который итерируется по значениям, возвращаемым генератором `countdown`, и выводит каждое значение на экран.
В результате выполнения кода будет выведен обратный отсчет от 5 до 0.


## Самостоятельная работа. 
### Задание 1.
Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили 
реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте
функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции
потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает
возможность “доставать” промежуточные результаты по одному).
Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.
### Результат
```python
def fib(n):
    a, b = 1, 1
    for i in range(n):
        yield a
        a, b = b, a + b


# Пример использования для вывода первых 200 чисел Фибоначчи
n = 200
fibonacci_sequence = list(fib(n))

# Вывод результата
print(f"Последовательность Фибоначчи ({n} чисел):")
print(fibonacci_sequence[-1])  # Вывод последнего числа для проверки
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/1.png)
### Выводы
Этот код создает функцию `fib`, которая генерирует n чисел Фибоначчи при помощи итераторов. Затем, создается список `fibonacci_sequence`, содержащий первые 200 чисел Фибоначчи, и выводится последнее число этой последовательности. Обратите внимание, что использование `list()` преобразует итератор в список для удобства вывода.

### Задание 2.
К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно
находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла.
### Результат
```python
def fib(n):
    a, b = 1, 1
    with open("fib.txt", "w") as file:
        for i in range(n):
            file.write(str(a) + "\n")
            yield a
            a, b = b, a + b


# Пример использования для вывода первых 200 чисел Фибоначчи
n = 200
fibonacci_sequence = list(fib(n))

# Вывод результата
print(f"Последовательность Фибоначчи ({n} чисел):")
print(fibonacci_sequence[-1])  # Вывод последнего числа для проверки
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/2.png)
![](https://github.com/smariasssss/SoftwareEngineering/blob/2c525d6f63d1e04b7ea8172669ba3f03b5f1a0a9/pics/2_2.png)
### Выводы
Данный код сохраняет каждое число Фибоначчи в файл "fib.txt":
После выполнения этого кода в файле "fib.txt" будут записаны все числа Фибоначчи по одному на каждой строке. Пожалуйста, сделайте скриншот получившегося файла "fib.txt" для демонстрации результатов.


## Общие выводы по теме.
В общем, итераторы и генераторы обеспечивают удобный способ работы с коллекциями данных в Python. Они позволяют перебирать элементы коллекций, не загружая все элементы в память одновременно, что делает их очень эффективными для работы с большими наборами данных. Основное отличие генераторов от итераторов заключается в том, как они создаются. Итераторы требуют больше кода и больше понимания протокола итератора. Генераторы же позволяют создать итератор более простым и удобным способом.
