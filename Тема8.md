# Тема 8. Введение в ООП
Отчет по Теме №8 выполнила:
- Санжанова Мария Олеговна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб     |
| ------ | ------ |-------------|
| Задание 1 | + | +   |
| Задание 2 | + | +   |
| Задание 3 | + | +   |
| Задание 4 | + | +   |
| Задание 5 | + | +   |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа.
### Задание 1.
Создайте класс "Саг" с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.
### Результат.
``` python
# Определение класса Car
class Car:
    # Конструктор класса Car с двумя параметрами: make (марка) и model (модель)
    def __init__(self, make, model):
        # Устанавливаем атрибуты make и model
        self.make = make
        self.model = model

# Создание объекта класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
```
### Выводы.
В этом коде определен класс "Car", который имеет конструктор `init`, который инициализирует атрибуты "make" и "model" объекта класса. Затем создается объект `my_car` этого класса, который представляет автомобиль марки "Toyota" и модели "Corolla".

### Задание 2.
Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину "поехать". Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль. 
### Результат.
``` python
# Определение класса Car
class Car:
    # Конструктор класса Car с двумя параметрами: make (марка) и model (модель)
    def __init__(self, make, model):
        # Устанавливаем атрибуты make и model
        self.make = make
        self.model = model

    # Метод drive для класса Car
    def drive(self):
        # Выводим сообщение о том, что машина движется, указывая марку и модель
        print(f"Driving the {self.make} {self.model}")

# Создание объекта класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")

# Вызываем метод drive для объекта my_car
my_car.drive()
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/2.png)
### Выводы.
В этом коде определен класс "Car", у которого есть конструктор для установки марки и модели автомобиля, а также метод `drive`, который выводит сообщение о том, что машина движется и указывает ее марку и модель. После создания объекта `my_car` и вызова метода `drive` на нем, выводится сообщение "Driving the Toyota Corolla".

### Задание 3.
Создайте новый класс "ElectricCar" с методом "charge" и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Результат.
``` python
# Определение класса Car
class Car:
    # Конструктор класса Car с двумя параметрами: make (марка) и model (модель)
    def __init__(self, make, model):
        # Устанавливаем атрибуты make и model
        self.make = make
        self.model = model

    # Метод drive для класса Car
    def drive(self):
        # Выводим сообщение о том, что машина движется, указывая марку и модель
        print(f"Driving the {self.make} {self.model}")

# Создание объекта класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")

# Вызываем метод drive для объекта my_car
my_car.drive()


# Определение класса ElectricCar, который является подклассом класса Car
class ElectricCar(Car):
    # Конструктор класса ElectricCar с тремя параметрами: make, model и battery_capacity
    def __init__(self, make, model, battery_capacity):
        # Вызываем конструктор суперкласса (класса Car) для установки марки и модели
        super().__init__(make, model)
        # Устанавливаем атрибут battery_capacity
        self.battery_capacity = battery_capacity

    # Метод charge для класса ElectricCar
    def charge(self):
        # Выводим сообщение о том, что электрическая машина заряжается, указывая марку, модель и ёмкость аккумулятора
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")

# Создание объекта класса ElectricCar с маркой "Tesla", моделью "Model S" и аккумулятором ёмкостью 75 kWh
my_electric_car = ElectricCar("Tesla", "Model S", 75)

# Вызываем метод drive для объекта my_electric_car (унаследованный от класса Car)
my_electric_car.drive()

# Вызываем метод charge для объекта my_electric_car (специфичный для класса ElectricCar)
my_electric_car.charge()
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/3.png)
### Выводы.
В этом коде определены два класса: "Car" и "ElectricCar", где "ElectricCar" является подклассом "Car". Оба класса имеют метод `drive`, но "ElectricCar" также имеет метод `charge`, который уникален для него. Создаются объекты обоих классов, и вызываются их методы для демонстрации работы.

### Задание 4.
Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Результат.
``` python
# Определение класса Car
class Car:
    # Конструктор класса Car с двумя параметрами: make (марка) и model (модель)
    def __init__(self, make, model):
        # Устанавливаем атрибуты make и model
        self._make = make
        self.__model = model

    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

# Создание объекта класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
print(my_car._make) # Доступ к защищённому атрибуту
# print(my_car.__model) # Ошибка! Приватный атрибут недоступен.
my_car.drive()
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/4.png)
### Выводы.
В данном коде определен класс "Car", и у него есть атрибуты `self._make` и `self.__model`. Давайте рассмотрим выводы, которые происходят при выполнении кода:
`print(my_car._make)`: Этот код печатает значение атрибута `_make`, и так как `_make` является "защищенным" атрибутом, то доступ к нему возможен, и вывод будет "Toyota".
`print(my_car.__model)`: Этот код вызовет ошибку, так как атрибут `__model` является "приватным" и не доступен вне класса. 
Вызывается метод `drive` объекта `my_car`, который выводит сообщение "Driving the Toyota Corolla", используя значения атрибутов `_make` и `__model`.

Таким образом, код демонстрирует разницу между "защищенными" и "приватными" атрибутами в Python, и как к ним можно или нельзя получить доступ извне класса.

### Задание 5.
Реализуйте полиморфизм создав основной (общий) класс "Shape", а также еще два класса "Rectangle" и "Circle". Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
### Результат.
``` python
# Определение базового (общего) класса Shape
class Shape:
    def area(self):
        pass

# Определение класса Rectangle, который является подклассом Shape
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        # Метод для подсчета площади прямоугольника
        return self.width * self.height

# Определение класса Circle, который также является подклассом Shape
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        # Метод для подсчета площади круга
        return 3.14 * self.radius * self.radius

# Создание объектов разных фигур
rectangle = Rectangle(4, 5) # Прямоугольник с шириной 4 и высотой 5
circle = Circle(3) # Круг с радиусом 3

# Создание массива с фигурами
shapes = [rectangle, circle]

# Вывод площадей фигур с использованием полиморфизма
for shape in shapes:
    print(f"Площадь фигуры: {shape.area()}")
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/5.png)
### Выводы.
Этот код демонстрирует принцип полиморфизма в Python. У нас есть базовый класс "Shape", который определяет метод `area`. Затем есть два подкласса, "Rectangle" и "Circle", которые наследуются от "Shape" и реализуют метод `area` для подсчета площади прямоугольника и круга соответственно.
Далее создаются объекты `rectangle` и `circle`, а затем помещаются в список `shapes`. Затем, используя цикл, вызывается метод `area` для каждой фигуры в списке `shapes`, и в консоль выводятся их площади.


## Самостоятельная работа.
### Задание 1.
Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Результат.
```python
# Определение базового класса Animal
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        pass

# Подкласс Dog (собака), наследуется от Animal
class Dog(Animal):
    def make_sound(self):
        return f"{self.name} лает: Гав-гав!"

# Подкласс Cat (кошка), также наследуется от Animal
class Cat(Animal):
    def make_sound(self):
        return f"{self.name} мяукает: Мяу-мяу!"

# Создание объектов разных животных
dog = Dog("Шарик")
cat = Cat("Мурка")

# Вызов методов make_sound для каждого животного
print(dog.make_sound())  # Вывод: "Шарик лает: Гав-гав!"
print(cat.make_sound())  # Вывод: "Мурка мяукает: Мяу-мяу!"
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/6.png)
### Выводы.
В данном примере создан класс "Animal" с подклассами "Dog" и "Cat". Каждый подкласс переопределяет метод `make_sound` для представления своего уникального звука. Создаются объекты "dog" и "cat", а затем вызываются их методы `make_sound` для вывода соответствующих звуков в консоли.


### Задание 2.
Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях.
Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Результат.
```python
# Определение базового класса Animal
class Animal:
    def __init__(self, name, age, color):
        self.name = name
        self.age = age
        self.color = color

    def make_sound(self):
        pass

    def info(self):
        return f"{self.name} - возраст: {self.age} лет, цвет: {self.color}"

# Подкласс Dog (собака), наследуется от Animal
class Dog(Animal):
    def make_sound(self):
        return f"{self.name} лает: Гав-гав!"

# Подкласс Cat (кошка), также наследуется от Animal
class Cat(Animal):
    def make_sound(self):
        return f"{self.name} мяукает: Мяу-мяу!"

# Создание объектов разных животных
dog = Dog("Шарик", 3, "рыжий")
cat = Cat("Мурка", 2, "белый")

# Вызов методов info и make_sound для каждого животного
print(dog.info())      # Вывод: "Шарик - возраст: 3 лет, цвет: коричневый"
print(cat.info())      # Вывод: "Мурка - возраст: 2 лет, цвет: серый"
print(dog.make_sound())  # Вывод: "Шарик лает: Гав-гав!"
print(cat.make_sound())  # Вывод: "Мурка мяукает: Мяу-мяу!"
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/7.png)
### Выводы.
В этом обновленном коде добавлены атрибуты "age" (возраст) и "color" (цвет) для каждого животного, а также метод "info", который позволяет получить информацию о животном, включая его имя, возраст и цвет шерсти.

### Задание 3.
Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Результат.
```python
# Определение базового класса Animal
class Animal:
    def __init__(self, name, age, color):
        self.name = name
        self.age = age
        self.color = color

    def make_sound(self):
        pass

    def info(self):
        return f"{self.name} - возраст: {self.age} лет, цвет: {self.color}"

# Подкласс Dog (собака), наследуется от Animal
class Dog(Animal):
    def make_sound(self):
        return f"{self.name} лает: Гав-гав!"

# Подкласс Cat (кошка), также наследуется от Animal
class Cat(Animal):
    def make_sound(self):
        return f"{self.name} мяукает: Мяу-мяу!"

# Подкласс Bird (птица), также наследуется от Animal
class Bird(Animal):
    def __init__(self, name, age, color, species, can_fly):
        super().__init__(name, age, color)
        self.species = species
        self.can_fly = can_fly

    def make_sound(self):
        return f"{self.name} 'говорит': Курлык-курлык!"

    def info(self):
        animal_info = super().info()
        return f"{animal_info}, вид: {self.species}, способность летать: {self.can_fly}"

# Создание объектов разных животных
dog = Dog("Шарик", 3, "рыжий")
cat = Cat("Мурка", 2, "белый")
bird = Bird("Голубь", 1, "серый", "голубиный", True)

# Вызов методов info и make_sound для каждого животного
print(dog.info())      # Вывод: "Шарик - возраст: 3 лет, цвет: рыжий"
print(cat.info())      # Вывод: "Мурка - возраст: 2 лет, цвет: белый"
print(bird.info())     # Вывод: "Голубь - возраст: 1 лет, цвет: серый, вид: голубиный, способность летать: True"
print(dog.make_sound())  # Вывод: "Шарик лает: Гав-гав!"
print(cat.make_sound())  # Вывод: "Мурка мяукает: Мяу-мяу!"
print(bird.make_sound()) # Вывод: "Голубь 'говорит': Курлык-курлык!"
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/8.png)
### Выводы.
Добавим подкласс "Bird", который будет представлять птицу. Класс "Bird" будет иметь свои уникальные атрибуты, такие как "species" (вид птицы) и "can_fly" (способность летать). 
В этом обновленном коде создан подкласс "Bird", который наследуется от "Animal". Класс "Bird" имеет дополнительные атрибуты "species" и "can_fly", а также переопределенные методы `make_sound` и `info`. Создаются объекты "dog", "cat" и "bird", и для каждого из них вызываются методы для получения информации и демонстрации звуков.

### Задание 4.
Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Результат.
```python
# Определение базового класса Animal
class Animal:
    def __init__(self, name, age, color):
        self.name = name
        self.age = age
        self.color = color
        self.__hidden_attr = "Это приватный атрибут"

    def make_sound(self):
        pass

    def info(self):
        return f"{self.name} - возраст: {self.age} лет, цвет: {self.color}"

    def __hidden_method(self):
        return "Это приватный метод"

# Подкласс Dog, наследуется от Animal
class Dog(Animal):
    def make_sound(self):
        return f"{self.name} лает: Гав-гав!"

    def show_hidden_info(self):
        # Метод подкласса для доступа к скрытому атрибуту родительского класса
        return self._Animal__hidden_attr  # Доступ к скрытому атрибуту

# Подкласс Cat, наследуется от Animal
class Cat(Animal):
    def make_sound(self):
        return f"{self.name} мяукает: Мяу-мяу!"

# Подкласс Bird, наследуется от Animal
class Bird(Animal):
    def __init__(self, name, age, color, species, can_fly):
        super().__init__(name, age, color)
        self.species = species
        self.can_fly = can_fly

    def make_sound(self):
        return f"{self.name} 'говорит': Курлык-курлык!"

    def info(self):
        animal_info = super().info()
        return f"{animal_info}, вид: {self.species}, способность летать: {self.can_fly}"

# Создание объектов разных животных
dog = Dog("Шарик", 3, "рыжий")
cat = Cat("Мурка", 2, "белый")
bird = Bird("Голубь", 1, "серый", "голубиный", True)

# Вызов методов info и make_sound для каждого животного
print(dog.info())      # Вывод: "Шарик - возраст: 3 лет, цвет: рыжий"
print(cat.info())      # Вывод: "Мурка - возраст: 2 лет, цвет: белый"
print(bird.info())     # Вывод: "Голубь - возраст: 1 лет, цвет: серый, вид: голубиный, способность летать: True"
print(dog.make_sound())  # Вывод: "Шарик лает: Гав-гав!"
print(cat.make_sound())  # Вывод: "Мурка мяукает: Мяу-мяу!"
print(bird.make_sound()) # Вывод: "Голубь 'говорит': Курлык-курлык!"

# Попытка доступа к скрытому атрибуту извне класса (вызовет ошибку)
# print(dog.__hidden_attr)

# Доступ к скрытому методу из подкласса
print(dog.show_hidden_info())  # Вывод: "Это приватный атрибут"
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/9.png)
### Выводы.
Так как мой предыдущий код уже имеет инкапсуляцию в виде защищенных атрибутов и методов, для полной инкапсуляции можно добавить приватные атрибуты и методы с использованием двойного подчеркивания __, которые будут недоступны извне класса.
Здесь добавлены скрытый атрибут `__hidden_attr` и скрытый метод `__hidden_method` в родительский класс "Animal". В подклассе "Dog" добавлен метод `show_hidden_info`, который позволяет получить доступ к скрытому атрибуту родительского класса. Важно отметить, что попытка доступа к скрытому атрибуту извне класса вызовет ошибку, но из подкласса это возможно.

### Задание 5.
Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
### Результат.
```python
# Определение базового класса Vehicle
class Vehicle:
    def __init__(self, name):
        self.name = name

    def move(self):
        pass

# Подкласс Car, наследуется от Vehicle
class Car(Vehicle):
    def move(self):
        return f"{self.name} движется по дороге на четырех колесах."

# Подкласс Bicycle, также наследуется от Vehicle
class Bicycle(Vehicle):
    def move(self):
        return f"{self.name} движется по велосипедной дорожке на двух колесах."

# Создание объектов разных транспортных средств
car = Car("Toyota")
bicycle = Bicycle("Trek")

# Вызов методов move для каждого транспортного средства
print(car.move())     # Вывод: "Toyota движется по дороге на четырех колесах."
print(bicycle.move()) # Вывод: "Trek движется по велосипедной дорожке на двух колесах."
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/f324f0e2182f74136d77fb90a712b91dd5699685/pics/10.png)
### Выводы.
В этом примере я создала базовый класс "Vehicle" с методом `move`, который будет переопределен в подклассах. Затем были созданы подклассы "Car" и "Bicycle", каждый из которых переопределяет метод `move` для описания движения соответствующего транспортного средства. При вызове метода `move` для каждого объекта, вызывается соответствующая версия метода из подклассов, что демонстрирует полиморфизм.

## Общие выводы по теме.
Мы изучили основы объектно-ориентированного программирования на языке Python. Начиная с концепций сложности и абстракции, мы изучили основные концепции ООП, такие как классы, объекты, наследование, инкапсуляцию и полиморфизм.
Мы познакомились с синтаксисом описания классов, методов и атрибутов, а также узнали, как создавать экземпляры классов и вызывать связанные и не связанные методы.
Кроме того, была изучена инициализация и протоколы, свойства, наследование
Все эти концепции важны для создания масштабируемых и легко поддерживаемых программ. 
