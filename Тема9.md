# Тема 9. Концепции и принципы ООП
Отчет по Теме №9 выполнила:
- Санжанова Мария Олеговна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб     |
| ------ | ------ |-------------|
| Задание 1 | + | +   |
| Задание 2 | + | +   |
| Задание 3 | + | +   |
| Задание 4 | + | +   |
| Задание 5 | + | +   |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа.
### Задание 1. ###
Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию _init_(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

### Результат ###
![](https://github.com/smariasssss/SoftwareEngineering/blob/40538cd74ac7da671a8c9590ca6df7bac64b3f07/pics/1.png)

### Выводы ###
Код определяет класс `Ivan`, который имеет атрибут `name`, ограниченный с помощью атрибута `__slots__`.который используется для определения ограниченного набора атрибутов объекта класса, что может помочь в управлении памятью и предотвращении динамического добавления новых атрибутов.
Конструктор класса `__init__()` принимает имя в качестве параметра. Затем создаются два объекта `Ivan`: `person1` с именем 'Алексей' и `person2` с именем 'Иван'. 
Далее, код пытается вывести значения атрибута `name` для обоих объектов.
Из-за использования атрибута `__slots__`, попытка добавления атрибута `surname` к объекту `person2` вызовет ошибку `AttributeError`, так как атрибут `surname` не указан в списке `__slots__`.


### Задание 2. ###
Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором
будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

### Результат ###
![](https://github.com/smariasssss/SoftwareEngineering/blob/40538cd74ac7da671a8c9590ca6df7bac64b3f07/pics/2.png)

### Выводы ###
Этот код определяет класс `Icecream`, который имеет конструктор `__init__`, метод `composition`, и атрибут `ingredient`.
В конструкторе `__init__`, объект `Icecream` может быть инициализирован с атрибутом `ingredient`. Если `ingredient` - это строка, то он устанавливается как атрибут `ingredient` объекта. В противном случае, `ingredient` остается равным `None`.
Метод `composition` выводит информацию о составе мороженого. Если `ingredient` не равен `None`, он выводит "Мороженое с [ingredient]", иначе выводит "Обычное мороженое".
После определения класса `Icecream`, выполняются следующие операции:
1. Создается объект `icecream` без аргументов при вызове `Icecream()`. После этого вызывается метод `composition()`, который выводит "Обычное мороженое", так как атрибут `ingredient` остается равным `None`.
2. Создается новый объект `icecream` с аргументом 'шоколадом' при вызове `Icecream('шоколадом')`. Метод `composition()` вызывается снова, и теперь он выводит "Мороженое с шоколадом".
3. Создается еще один объект `icecream` с аргументом 5 при вызове `Icecream(5)`. В данном случае, `ingredient` не является строкой, и поэтому `self.ingredient` устанавливается в `None`. При вызове `composition()` выводится "Обычное мороженое", так как атрибут `ingredient` равен `None`.

### Задание 3. ###
Петя - начинающий программист и на занятиях ему сказали реализовать икапсу... что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу... что-то - это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором.
После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

### Результат ###
![](https://github.com/smariasssss/SoftwareEngineering/blob/40538cd74ac7da671a8c9590ca6df7bac64b3f07/pics/3.png)

### Выводы ###
В консоли выводится ошибка по нескольким причинам:
1. Неправильное объявление методов `set_value`, `get_value` и `del_value` внутри конструктора `__init__`. Они должны быть методами класса, но в данном коде они объявлены внутри метода `__init__`, что делает их локальными для этого метода.
2. Метод `del_value` должен быть методом удаления атрибута, а не создания свойства.
3. Отсутствие вызова `__init__` при создании объекта класса.

Корректный код должен выглядеть следующим образом:

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value  # установка значения атрибута

    def get_value(self):
        return self._value  # получение значения атрибута

    def del_value(self):  # удаление атрибута
        del self._value

    # Используем property для создания свойства value
    value = property(get_value, set_value, del_value, "Свойство value")

# Создаем объект класса
obj = MyClass(42)

# Используем свойство value
print(obj.value)

obj.set_value(45)
print(obj.value)

obj.set_value(100)
print(obj.value)

# Удаляем свойство value
del obj.value

```
Был создан класс `MyClass` с атрибутом `_value`, а затем создано свойство `value`, используя `property`, которое позволяет управлять доступом к атрибуту через методы `set_value`, `get_value` и `del_value`.

### Задание 4. ###
Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи "наследования" объяснить компьютеру что кошки и собаки - это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

### Результат ###
![](https://github.com/smariasssss/SoftwareEngineering/blob/40538cd74ac7da671a8c9590ca6df7bac64b3f07/pics/4.png)

### Выводы ###
Этот код представляет собой простую иерархию классов, где классы `Dog` и `Cat` наследуются от базового класса `Mammal`. 
Код демонстрирует концепцию наследования и использование атрибутов класса и экземпляра.
`Mammal` — базовый класс для `Dog` и `Cat`. У него есть атрибут `className`, установленный в строку 'Mammal'. Этот атрибут является атрибутом класса, общим для всех экземпляров этого класса. У `Dog` есть атрибут `species`, установленный в строку 'canine', и атрибут `sounds`, установленный в строку 'wow'. `Dog` не определяет собственного `className`, но поскольку он наследует от `Mammal`, у него есть доступ к `className` из родительского класса. У `Cat` есть атрибут `species`, установленный в строку 'feline', и атрибут `sounds`, установленный в строку 'meow'. Как и у `Dog`, `Cat` не определяет собственного `className`, но наследует его от `Mammal`.
Далее создаются экземпляры `Dog` и `Cat`. Выводится информация о каждом экземпляре, используя атрибуты классов и их значения. Когда создается экземпляр `Dog`, он наследует атрибут `className` от `Mammal`, и выводит информацию о себе и своих атрибутах. То же самое происходит и с экземпляром `Cat`.

### Задание 5. ###
На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

### Результат ###
![](https://github.com/smariasssss/SoftwareEngineering/blob/40538cd74ac7da671a8c9590ca6df7bac64b3f07/pics/5.png)

### Выводы ###
Этот код представляет собой пример использования статических методов в Python и вызова методов через функцию. 
Класс `Russian` содержит статический метод `greeting`, который выводит "Привет" на русском.
Класс `English` аналогично содержит статический метод `greeting`, который выводит "Hello" на английском.
Функция `greet` принимает аргумент `Language`, предполагая, что он является объектом с методом `greeting`, и вызывается метод `greeting` объекта `Language`.
Далее создается экземпляр класса `Russian` с именем `ivan`. Вызывается функция `greet` с аргументом `ivan`, который является объектом класса `Russian`. Потом выводится "Привет".
Аналогично создается экземпляр класса `English` с именем `john`, и вызывается функция `greet` с аргументом `john`, который является объектом класса `English`. Затем выводится "Hello".




### Задание "Садовник и помидоры".
**Классовая структура:**

Есть **Помидор** со следующими характеристиками:
- Индекс
- Стадия созревания (стади: отсутствует, цветение, зеленый, красный)

**Помидор** может:
- Расти (переходить на следующую стадию созревания)
- Предоставлять информацию о своей зрелости

Есть **Куст с помидорами**, который:
- Содержит список томатов, которые на нем растут
А также может:
- Расти вместе с томатами
- Предоставять информацию о зрелости весх томатов
- Предоставлять урожай
  
И также есть **Садовник**, который имеет:
- Растение, за которым он ухаживает

Он может:
- Ухаживать за растением
- Собирать с него урожай

**Задание:**
Класс **Tomato**:
1) Создайте класс **Tomato**
2) Создайте статическое свойство **states**, которое будет содержать все стадии созревания помидора
3) Создайте метод **_init_()**, внутри которого будут определены два динамических свойства: **_index** (передается параметром) и **_state**
(принимает первое значение из словаря **states**). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4) Создайте метод **grow()**, который будет переводить томат на следующую стадию созревания
Создайте метод is **ripe()**, который будет проверять, что томат созрел

Класс **TomatoBush**:
1) Создайте класс **TomatoBush**
2) Определите метод **_init_()**, который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса **Tomato**. Данный список будет храниться внутри динамического свойства **tomatoes**
3) Создайте метод **grow_all()**, который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод **all_are_ripe()**, который будет возвращать **True**, если все томаты из списка стали спелыми
5) Создайте метод **give_away_all()**, который будет чистить список томатов после сбора урожая

Класс **Gardener**:
1) Создайте класс **Gardener**
2) Создайте метод **_init_()**, внутри которого будут определены два динамических свойства: **name** (передается параметром, является публичным) и **_plant** (принимает объект класса **TomatoBush**). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод **work()**, который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод **harvest**, который проверяет, все ли плоды созрели.
Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод **knowledge_base()**, который выведет в консоль справку по садоводству

**Тесты:**
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай

### Результат ###
```python
class Tomato:
    # Созревание помидора
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}

    def __init__(self, index):
        self._index = index
        self._state = 0

    # Переход к следующей стадии созревания
    def grow(self):
        self._change_state()

    # Проверка, созрел ли помидор
    def is_ripe(self):
        if self._state == 3:
            return True
        return False

    # Защищенные методы
    def _change_state(self):
        if self._state < 3:
            self._state += 1
        self._print_state()

    def _print_state(self):
        print(f'Tomato {self._index} {Tomato.states[self._state]}')


class TomatoBush:

    # Создаем список из объектов класса Tomato
    def __init__(self, num):
        self.tomatoes = [Tomato(index) for index in range(0, num)]

    # Переводим все помидоры из списка на следующий этап созревания
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # Проверяем, все ли помидоры созрели
    def all_are_ripe(self):
        return all([tomato.is_ripe() for tomato in self.tomatoes])

    # Собираем урожай
    def give_away_all(self):
        self.tomatoes = []


class Gardener:

    # Выдаем садовнику растение для ухода
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant

    # Ухаживаем за растением
    def work(self):
        print('Уход за растением...')
        self._plant.grow_all()
        print('Сбор урожая')

    # Собираем урожай
    def harvest(self):
        print('Садовник собирает урожай...')
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print('Урожай собран!')
        else:
            print('Слишком рано! Растение ещё не созрело.')

    # Статический метод ыводит справку по садоводству
    @staticmethod
    def knowledge_base():
        print('Справка по садоводству:')
        print('1. Не забывайте регулярно поливать и подкармливать растения')
        print('2. Определите правильное расстояние между растениями, чтобы они не мешали друг другу в росте')
        print('3. Удалите поврежденные листья и плоды, чтобы предотвратить распространение болезней')


# Тесты
if __name__ == '__main__':
    Gardener.knowledge_base()
    great_tomato_bush = TomatoBush(4)
    gardener = Gardener('Мария', great_tomato_bush)
    gardener.work()
    gardener.work()
    gardener.harvest()
    gardener.work()
    gardener.harvest()
```
![](https://github.com/smariasssss/SoftwareEngineering/blob/40538cd74ac7da671a8c9590ca6df7bac64b3f07/pics/Помидоры.png)

### Выводы ###
Код представляет собой пример объектно-ориентированного программирования в Python с использованием классов и объектов. Рассмотрим каждый класс и метод:
Сама суть работы кода представлена в описании задания.
Код выглядит структурированным и понятным, использует принципы ооп для представления сущностей и их взаимодействия. Он также содержит статический метод для вывода справки, что является хорошей практикой документирования функциональности классов.

## Общие выводы по теме.
Python позволяет не только использовать имеющиеся классы, но и создавать собственные, которые могут использоваться как любые встроенные типы данных. 
Большинство классов содержат в себе (инкапсулируют) не только поля (данные), но и методы. В Python традиционно поля и методы вместе называются атрибутами (членами) класса. Доступ к члену класса можно получить через '.'. Например, класс str хранит строки символов Юникода в виде данных и поддерживает методы, такие как str.count().
Все атрибуты класса являются общедоступными, а все методы переопределяемыми.