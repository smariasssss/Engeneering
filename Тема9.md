# Тема 9. Концепции и принципы ООП
Отчет по Теме №9 выполнила:
- Санжанова Мария Олеговна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб     |
| ------ | ------ |-------------|
| Задание 1 | + | +   |
| Задание 2 | + | +   |
| Задание 3 | + | +   |
| Задание 4 | + | +   |
| Задание 5 | + | +   |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа.
### Задание 1. ###
Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию _init_(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

### Результат ###

### Выводы ###
Код определяет класс `Ivan`, который имеет атрибут `name`, ограниченный с помощью атрибута `__slots__`.который используется для определения ограниченного набора атрибутов объекта класса, что может помочь в управлении памятью и предотвращении динамического добавления новых атрибутов.
Конструктор класса `__init__()` принимает имя в качестве параметра. Затем создаются два объекта `Ivan`: `person1` с именем 'Алексей' и `person2` с именем 'Иван'. 
Далее, код пытается вывести значения атрибута `name` для обоих объектов.
Из-за использования атрибута `__slots__`, попытка добавления атрибута `surname` к объекту `person2` вызовет ошибку `AttributeError`, так как атрибут `surname` не указан в списке `__slots__`.


### Задание 2. ###
Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором
будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

### Результат ###

### Выводы ###
Этот код определяет класс `Icecream`, который имеет конструктор `__init__`, метод `composition`, и атрибут `ingredient`.
В конструкторе `__init__`, объект `Icecream` может быть инициализирован с атрибутом `ingredient`. Если `ingredient` - это строка, то он устанавливается как атрибут `ingredient` объекта. В противном случае, `ingredient` остается равным `None`.
Метод `composition` выводит информацию о составе мороженого. Если `ingredient` не равен `None`, он выводит "Мороженое с [ingredient]", иначе выводит "Обычное мороженое".
После определения класса `Icecream`, выполняются следующие операции:
1. Создается объект `icecream` без аргументов при вызове `Icecream()`. После этого вызывается метод `composition()`, который выводит "Обычное мороженое", так как атрибут `ingredient` остается равным `None`.
2. Создается новый объект `icecream` с аргументом 'шоколадом' при вызове `Icecream('шоколадом')`. Метод `composition()` вызывается снова, и теперь он выводит "Мороженое с шоколадом".
3. Создается еще один объект `icecream` с аргументом 5 при вызове `Icecream(5)`. В данном случае, `ingredient` не является строкой, и поэтому `self.ingredient` устанавливается в `None`. При вызове `composition()` выводится "Обычное мороженое", так как атрибут `ingredient` равен `None`.

### Задание 3. ###
Петя - начинающий программист и на занятиях ему сказали реализовать икапсу... что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу... что-то - это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором.
После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

### Результат ###

### Выводы ###


### Задание 4. ###
Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи "наследования" объяснить компьютеру что кошки и собаки - это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

### Результат ###

### Выводы ###


### Задание 5. ###
На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

### Результат ###

### Выводы ###




### Задание Садовник и помидоры.
**Классовая структура:**

Есть **Помидор** со следующими характеристиками:
- Индекс
- Стадия созревания (стади: отсутствует, цветение, зеленый, красный)

**Помидор** может:
- Расти (переходить на следующую стадию созревания)
- Предоставлять информацию о своей зрелости

Есть **Куст с помидорами**, который:
- Содержит список томатов, которые на нем растут
А также может:
- Расти вместе с томатами
- Предоставять информацию о зрелости весх томатов
- Предоставлять урожай
  
И также есть **Садовник**, который имеет:
- Растение, за которым он ухаживает

Он может:
- Ухаживать за растением
- Собирать с него урожай

**Задание:**
Класс **Tomato**:
1) Создайте класс **Tomato**
2) Создайте статическое свойство **states**, которое будет содержать все стадии созревания помидора
3) Создайте метод **_init_()**, внутри которого будут определены два динамических свойства: **_index** (передается параметром) и **_state**
(принимает первое значение из словаря **states**). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4) Создайте метод **grow()**, который будет переводить томат на следующую стадию созревания
Создайте метод is **ripe()**, который будет проверять, что томат созрел

Класс **TomatoBush**:
1) Создайте класс **TomatoBush**
2) Определите метод **_init_()**, который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса **Tomato**. Данный список будет храниться внутри динамического свойства **tomatoes**
3) Создайте метод **grow_all()**, который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод **all_are_ripe()**, который будет возвращать **True**, если все томаты из списка стали спелыми
5) Создайте метод **give_away_all()**, который будет чистить список томатов после сбора урожая

Класс **Gardener**:
1) Создайте класс **Gardener**
2) Создайте метод **_init_()**, внутри которого будут определены два динамических свойства: **name** (передается параметром, является публичным) и **_plant** (принимает объект класса **TomatoBush**). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод **work()**, который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод **harvest**, который проверяет, все ли плоды созрели.
Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод **knowledge_base()**, который выведет в консоль справку по садоводству

**Тесты:**
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай

### Результат ###
```python
class Tomato:
    # Созревание помидора
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}

    def __init__(self, index):
        self._index = index
        self._state = 0

    # Переход к следующей стадии созревания
    def grow(self):
        self._change_state()

    # Проверка, созрел ли помидор
    def is_ripe(self):
        if self._state == 3:
            return True
        return False

    # Защищенные методы
    def _change_state(self):
        if self._state < 3:
            self._state += 1
        self._print_state()

    def _print_state(self):
        print(f'Tomato {self._index} {Tomato.states[self._state]}')


class TomatoBush:

    # Создаем список из объектов класса Tomato
    def __init__(self, num):
        self.tomatoes = [Tomato(index) for index in range(0, num)]

    # Переводим все помидоры из списка на следующий этап созревания
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # Проверяем, все ли помидоры созрели
    def all_are_ripe(self):
        return all([tomato.is_ripe() for tomato in self.tomatoes])

    # Собираем урожай
    def give_away_all(self):
        self.tomatoes = []


class Gardener:

    # Выдаем садовнику растение для ухода
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant

    # Ухаживаем за растением
    def work(self):
        print('Уход за растением...')
        self._plant.grow_all()
        print('Сбор урожая')

    # Собираем урожай
    def harvest(self):
        print('Садовник собирает урожай...')
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print('Урожай собран!')
        else:
            print('Слишком рано! Растение ещё не созрело.')

    # Статический метод ыводит справку по садоводству
    @staticmethod
    def knowledge_base():
        print('Справка по садоводству:')
        print('1. Не забывайте регулярно поливать и подкармливать растения')
        print('2. Определите правильное расстояние между растениями, чтобы они не мешали друг другу в росте')
        print('3. Удалите поврежденные листья и плоды, чтобы предотвратить распространение болезней')


# Тесты
if __name__ == '__main__':
    Gardener.knowledge_base()
    great_tomato_bush = TomatoBush(4)
    gardener = Gardener('Мария', great_tomato_bush)
    gardener.work()
    gardener.work()
    gardener.harvest()
    gardener.work()
    gardener.harvest()
```

### Выводы ###


## Общие выводы по теме.
Использование базовых коллекций в Python позволяет эффективно организовывать, хранить и обрабатывать данные. Словари обычно применяются для ассоциативных отображений, а кортежи - когда важна неизменность данных или нужно гарантировать порядок элементов.